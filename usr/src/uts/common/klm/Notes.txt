
Status:

NLM client code almost ready. (at least lock/unlock)
Zones supprot were significantly improved.
Server code and monitor/unmonitor functions need more work.


NOTES:
1) It's a bit confusing that we have two modules: klmmod and klmops
where klmops depends from klmmod
klmmod is a server code + RPC functions + KLM internals implementation
klmops is a client code: klmpos.c + nlm_client.c
It seems pointless to separate klmpos from klmmod. May be it's better
to join them in one module? Actually I don't see any benefit in separation
of these two modules, the only thing we get from it is dependency hell.

2) klmmod.c has lm_safelock and lm_safemap functions.
The first one checks if it's "safe" to make lock request
and the second one checks if it's "safe" to mmap something
(i.e. if lock areas don't overlap with mmap areas).
Actually these functions are NFSv3 specific (well, at least the first one),
why don't we move it to NFSv3 and call them, say,
nfs3_safelock and nfs3_safemap?

3) nlm_impl.c contains nlm_next_sysid variable. This variables is
used for obtaining unique sysid for each NLM host. The problem is
this variable is shared between all zones and "uniqueness" of sysid
is weakly guarantied because we simply increment it each time we need
new sysid.
At first sight there is no problems, because it's 32 bit variable and
possibility that we'll have UINT_MAX hosts is very low. But there're 
two things I don't like:
 a) actually it 24 bit variable, because os/flock.c code has NLM_SYSID_CLIENT
    flag which combined with sysid when we need to ask flock subsystem if
    given client has any locks. For example:
    nlm_sysid_has_locks(NLM_SYSID_CLIENT | host->nh_sysid).
 b) It is shared between all zones. Zones can be used for high loeded
    testing. For example tester/developer/system administrator can write
    a script that adds/removes new hosts with very high frequency (just for testing)
    in several (or in a lot of) zones.
So there is a possibily that nlm_next_sysid
  a) will not fit in 24 bits (and it's really bad, because we have NLM_SYSID_CLIENT flag)
  b) will not unique (for example when sysid with number 1 is still active, counter
     overflows and at few steps we get sysid with number 1 again and it won't be unique)

4) I think in future it's better to replace TAILQ list implementation taken from
   BSD systems with Solaris'es lists just because they are widely used through the code.
   I think it's not neccessary to multiply entities.

5) May be some day we can separate nlm_impl.c on client and server parts?



Random things I noticed:

I think we need NLM sysid values to be unique across all zones.
(So don't make nlm_next_sysid into a per-zone value.)

The os/flock.c code expects sysids to be unique system-wide,
i.e. _not_ just unique per-zone.

I think we also want a separate sysid for every tuple of
client + netaddr, or server + netaddr.

Does the lock manager need to "hold" vnodes active
when there are locks granted to clients?
(I think it does need to, yes.)


I'm not sure which way I like the service stubs done.
Started with nlm_prot_svc.c (generated, and *.sed)
but now I like nlm_prog[234].c better.

Local statmon callbacks:

  NLM_SM_NOTIFY1 = 17, in old LM: PRV_CRASH, lm_crash
	Called when one of our clients reboots.
	Throw away locks held by this client.
	They can come back to reclaim them.
  NLM_SM_NOTIFY2 = 18, in old LM: PRV_RECOVERY, lm_recovery
	Called when one of our servers reboots.
	Do "recovery" (try to reclaim our locks).

