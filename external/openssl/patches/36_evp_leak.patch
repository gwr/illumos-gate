Patch developed in-house.  Solaris-specific; not suitable for upstream.

--- openssl-1.0.1f/crypto/evp/evp_enc.c.orig	Mon Feb 11 07:26:04 2013
+++ openssl-1.0.1f/crypto/evp/evp_enc.c	Mon Feb  3 16:40:48 2014
@@ -394,10 +394,14 @@
 		{
 		ret = M_do_cipher(ctx, out, NULL, 0);
 		if (ret < 0)
-			return 0;
+			{
+			ret = 0;
+			goto cleanup;
+			}
 		else 
 			*outl = ret;
-		return 1;
+		ret = 1;
+		goto cleanup;
 		}
 
 	b=ctx->cipher->block_size;
@@ -405,7 +409,8 @@
 	if (b == 1)
 		{
 		*outl=0;
-		return 1;
+		ret = 1;
+		goto cleanup;
 		}
 	bl=ctx->buf_len;
 	if (ctx->flags & EVP_CIPH_NO_PADDING)
@@ -413,10 +418,12 @@
 		if(bl)
 			{
 			EVPerr(EVP_F_EVP_ENCRYPTFINAL_EX,EVP_R_DATA_NOT_MULTIPLE_OF_BLOCK_LENGTH);
-			return 0;
+			ret = 0;
+			goto cleanup;
 			}
 		*outl = 0;
-		return 1;
+		ret = 1;
+		goto cleanup;
 		}
 
 	n=b-bl;
@@ -428,6 +435,12 @@
 	if(ret)
 		*outl=b;
 
+cleanup:
+	if (ctx->cipher->cleanup)
+		{
+		ctx->cipher->cleanup(ctx);
+		}
+
 	return ret;
 	}
 
@@ -501,6 +501,7 @@
 int EVP_DecryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl)
 	{
 	int i,n;
+	int err = 1;
 	unsigned int b;
 	*outl=0;
 
@@ -508,10 +509,14 @@
 		{
 		i = M_do_cipher(ctx, out, NULL, 0);
 		if (i < 0)
-			return 0;
+			{
+			err = 0;
+			goto cleanup;
+			}
 		else
 			*outl = i;
-		return 1;
+		err = 1;
+		goto cleanup;
 		}
 
 	b=ctx->cipher->block_size;
@@ -520,10 +525,12 @@
 		if(ctx->buf_len)
 			{
 			EVPerr(EVP_F_EVP_DECRYPTFINAL_EX,EVP_R_DATA_NOT_MULTIPLE_OF_BLOCK_LENGTH);
-			return 0;
+			err = 0;
+			goto cleanup;
 			}
 		*outl = 0;
-		return 1;
+		err = 1;
+		goto cleanup;
 		}
 	if (b > 1)
 		{
@@ -530,7 +537,8 @@
 		if (ctx->buf_len || !ctx->final_used)
 			{
 			EVPerr(EVP_F_EVP_DECRYPTFINAL_EX,EVP_R_WRONG_FINAL_BLOCK_LENGTH);
-			return(0);
+			err = 0;
+			goto cleanup;
 			}
 		OPENSSL_assert(b <= sizeof ctx->final);
 
@@ -542,7 +550,8 @@
 		if (n == 0 || n > (int)b)
 			{
 			EVPerr(EVP_F_EVP_DECRYPTFINAL_EX,EVP_R_BAD_DECRYPT);
-			return(0);
+			err = 0;
+			goto cleanup;
 			}
 		for (i=0; i<n; i++)
 			{
@@ -549,7 +558,8 @@
 			if (ctx->final[--b] != n)
 				{
 				EVPerr(EVP_F_EVP_DECRYPTFINAL_EX,EVP_R_BAD_DECRYPT);
-				return(0);
+				err = 0;
+				goto cleanup;
 				}
 			}
 		n=ctx->cipher->block_size-n;
@@ -559,7 +569,13 @@
 		}
 	else
 		*outl=0;
-	return(1);
+	err = 1;
+cleanup:
+	if (ctx->cipher->cleanup)
+		{
+		ctx->cipher->cleanup(ctx);
+		}
+	return err;
 	}
 
 void EVP_CIPHER_CTX_free(EVP_CIPHER_CTX *ctx)
